<!-- vim: foldmarker={{{,}}} foldenable foldmethod=marker tw=130
-->
<!DOCTYPE html>
<html>
    <head>
        <title>Tutorial de C</title>

        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
        <meta name="HandheldFriendly" content="true"/>
        <meta charset="UTF-8"/>

        <link rel="stylesheet" type="text/css" href="../style.css"/>

        <style>
            summary.big {
                font-size: 1.1em;
                font-weight: bold;
            }

            summary.todo {
                font-size: 0.9em;
                font-weight: lighter;
                font-style: italic;
            }
        </style>
    </head>

    <body><main>
        <details open>
            <summary>Tutorial de C</summary>

            <p class="subnode">Olá! Aqui eu vou tentar ajudar com algumas coisas de C.</p>
            <p class="subnode">Não é muita coisa. É mais um ponto de referência p/ algumas dúvidas q eu ja tirei.</p>

            <details class="subnode"><summary class="big">int main()</summary> <!-- {{{ -->

<p><code>main()</code> é o nome do "ponto de entrada" de um programa, geralmente. Então o que você quer que rode você coloca
ali.</p>

<p>Ela na verdade é o que chamamos de <b>função</b> (<a href="#s-funcoes">um pouco mais avançado - leia mais em baixo</a>), mas
basicamente é um pedaço de código que você pode rodar várias vezes. Outras coisas que veremos mais na frente, como
<code>printf()</code>, <code>scanf()</code> e <code>sqrt()</code>, são funções também, mas elas são definidas pelo compilador.</p>

<p>O <code>main()</code> é a gente que define, e o computador começa a rodar o programa por ali.</p>

<p>A partir daqui, a maioria dos códigos vai omitir o <code>int main()</code>, mas você precisa colocar o código dentro dele.</p>

<p>Então isso:</p>

<pre><code>int main() {
    int a = 10 + 20;
}
</code></pre>

<p>É a forma correta de escrever, enquanto isso:</p>

<pre><code>int a = 10 + 20;
</code></pre>

<p>É o que vai aparecer.</p>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">criando variáveis (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">tipos de dados (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="big">mostrando coisas na tela (com printf)</summary> <!-- {{{ -->

<p>O <code>printf</code> é uma função usada para mostrar coisas na tela.</p>
<p>Para usar, você precisa colocar <code>#include &lt;stdio.h&gt;</code> no início do código, antes do <code>int main()</code>.</p>

<p>Um exemplo de uso do printf seria:</p>

<pre><code>printf("Olá, mundo!");
</code></pre>

<p>Basicamente, você passa um texto (entre aspas<!-- TODO: definir o que é uma string lá em cima -->) com uma mensagem para mostrar na tela.</p>

<hr/>

<p>Mas como mostrar, por exemplo, um número que foi calculado no programa?</p>

<p>Para isso, você precisa usar os <code>%</code>s. Vejamos outro exemplo:</p>

<pre><code>int x = 0;
printf("O sucessor de x é %d", x+1);
</code></pre>

<p>Quando você usa o <code>%d</code> no texto do printf, a próxima coisa que você passar depois do texto vai ser colocada no lugar dele. Nesse caso, o programa mostraria <code>O sucessor de x é 1</code>.</p>

<p>E você pode usar isso várias vezes:</p>

<pre><code>int a = 1;
int b = 3;
printf("a=%d, b=%d, a+b=%d", a, b, a+b);
</code></pre>

<p>(Isso mostra <code>a=1, b=3, a+b=4</code>)</p>

<hr/>

<p>Agora cuidado: o <code>%d</code> é usado somente para <code>int</code>. Se você quiser passar outros tipos de valores, vai ter que usar outros códigos:</p>
<ul>
    <li>%d ou %i: int</li>
    <li>%x: int, hexadecimal</li>
    <li>%o: int, octal</li>
    <li>%u: unsigned int</li>

    <li>%c: char</li>
    <li>%f: float</li>
    <li>%lf: double (o código lf pq é abreviação "long float", que é equivalente)</li>
</ul>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="big">lendo coisas digitadas (com scanf)</summary> <!-- {{{ -->

<p>Além de saber como mostrar coisas na tela, é também muito útil saber sim ler coisas que o usuário digitar.</p>
<p>Para isso temos o <code>scanf</code>. Ele funciona de uma maneira parecida com o printf, mas o texto é um formato do que o usuário vai digitar, e o que você passa depois são as variáveis pra onde essas coisas digitadas vão.</p>

<p>Confuso? Enfim, um exemplo provavelmente ajuda mais:</p>

<pre><code>int x;
scanf("%d", &amp;x);
</code></pre>

<p>Aqui nós criamos uma variável <code>x</code> e usamos o scanf. Ao fazer isso, o programa vai parar até que o usuário digite algo e aperte enter. Ele então vai tentar pegar o texto que o usuário digitou, e, se for um número, colocar em <code>x</code>.</p>

<p>Esse programa aqui então é uma mini calculadora:</p>

<pre><code>int x;
printf("Digite x: ");
scanf("%d", &amp;x);
printf("x*5=%d", x*5);
</code></pre>

<p>Se eu digitar <code>20</code>, o resultado vai ser <code>x*5=100</code>.</p>

<hr/>

<p>Lembre-se de, ao colocar a variável, colocar o <code>&amp;</code> logo antes. Isso siginifica que, ao invés de você passar o que tá dentro da variável x, você está passando o <b>endereço</b> dela. Talvez eu explique isso algum dia direito, mas uma maneira simples de entender é: toda variável, quando o programa tá rodando, tá em algum lugar específico da memória. Passar o endereço seria indicar ao scanf onde na memória tá essa variável, para ele poder ir lá e colocar o valor que o usuário digitou ali.

<hr/>

<p>Os tipos de % usados aqui são basicamente os mesmos que você usaria no printf, então pode olhar a tabela de códigos de lá mesmo.</p>

            </details> <!-- }}} -->
            <details class="subnode"><summary class="big">comentários (// e /* */)</summary> <!-- {{{ -->

<p>Às vezes é bom poder anotar algo no código. Para isso, usamos os comentários.</p>
<p>Um comentário é um texto que não vira código - ele é essencialmente ignorado pelo compilador.</p>

<p>Em C, a maneira "clássica" de comentar é com o <code>/* */</code>. Você começa o comentário com <code>/*</code> e termina ele com <code>*/</code>.</p>

<pre><code>int x; /* olá! isso aqui é um comentário. */
scanf("%d", &amp;x); /* um comentário
de múltiplas linhas
:) */
</code></pre>

<p>O compilador ignora os comentários, então isso é equivalente a:</p>

<pre><code>int x;
scanf("%d", &amp;x);
</code></pre>

<p>Desde 1990(?) você pode também usar os comentários de uma-linha. Ao colocar o <code>//</code>, tudo até o fim daquela linha é ignorado.</p>

<pre><code>int x; // olá! isso aqui é um comentário.
scanf("%d", &amp;x);
// como eu quero colocar
// várias linhas, eu tenho
// que usar o // no início de cada linha.
</code></pre>

<p>Mais uma vez, o compilador ignora os comentários, e resulta em:</p>

<pre><code>int x;
scanf("%d", &amp;x);
</code></pre>

<hr/>

<p>Além de anotar coisas, comentários são úteis para ignorar um código por um tempo, sendo que você quer usar ele depois.</p>

<p>Alguns editores até tem telas específicas para comentar o texto selecionado, o que deixa isso bem prático (no VSCode é Ctrl+K, eu acho?)</p>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">bibliotecas, headers e include (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">constantes (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">lembrete: funções dentro de funções (A FAZER)</summary> <!-- {{{ -->
                explicar que srand(time(0)) é o mesmo que a=0, b=time(a), srand(b)
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">if ternário (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="big" id="s-time">obtendo o tempo atual com <code>time()</code></summary> <!-- {{{ -->
<p>Por agora essa explicação de tempo aqui é só algo simples p/ poder usar com números aleatórios.</p>

<p>Uma das maneiras mais básicas de obter informação sobre o tempo em C é usar a função <code>time()</code>, disponível no header <code>time.h</code>.</p>

<p>Eu peguei um protótipo dessa função (encontrei em <code>/usr/include/time.h</code> no meu computador) e simplifiquei:</p>

<pre><code>/* Retorna o tempo atual (em segundos) e coloca em *x se x não for NULL. */
time_t time(time_t *x);
</code></pre>

<p>Basicamente, ela é uma função que, quando chamada, retorna um <code>time_t</code> indicando o tempo, em forma de número (a quantidade de segundos passada desde ... 1 de janeiro de 1970, se eu não me engano).</p>

<p>Esse <code>time_t</code> é um <i>alias</i> ("apelido") de um número inteiro, então se tiver tendo dificuldade pra entender basta trocar <code>time_t</code> por <code>int</code> na cabeça.</p>

<p>Um programa simples que mostraria a quantidade de segundos atual é:</p>

<!-- A FAZER: confirmar isso aqui -->
<pre><code>time_t s;
s = time(NULL);
printf("Segundos: %d\n", s);
</code></pre>

<p>Se você parar pra ver, aqui eu estou passando um <code>NULL</code>. Ele basicamente indica que não é para o <code>time()</code> fazer nada de "colocar em *x" (como tem no texto lá em cima) e é só para retornar o valor. Mas, se você fizer:</p>

<pre><code>time_t s;
time(&amp;s);
printf("Segundos: %d\n", s);
</code></pre>

<p>Aqui você vai estar passando o <code>&amp;</code> (endereço) da variável <code>s</code> e isso vai fazer com que o <code>time()</code> coloque o valor nela, mesmo sem você ter usado o <code>=</code>. É tipo o <code>scanf()</code>.</p>

<p>Curiosidade: você poder usar tanto <code>x = time(NULL)</code> quanto <code>time(&amp;x)</code> é na verdade um legado de versões muito, muito velhas de C. Não vou explicar aqui mas consulte <a href="https://stackoverflow.com/questions/61432103/why-does-stdtime-have-an-unnecessary-parameter">essa pergunta no StackOverflow</a> se tiver com curiosidade.</p>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="big">geração de números aleatórios (com <code>rand()</code>)</summary> <!-- {{{ -->

<p>Alguns tipos de programa precisam fazer coisas aleatórias acontecerem (como sortear cartas em um baralho, ou rolar um dado). Em computadores, podemos fazer algo parecido através da geração de números aleatórios.</p>

<p>Para gerar números aleatórios podemos utilizar a função <code>rand()</code>, disponível em <code>stdlib.h</code></p>

<p>Essa função gera um número entre 0 e <code>RAND_MAX</code>, que é uma constante que também fica em <code>stdlib.h</code>. O valor dela é geralmente... 36727? alguma coisa assim.</p>

<p>Enfim. Vejamos esse código:</p>

<pre><code>printf("%d\n", rand());
printf("%d\n", rand());
printf("%d\n", rand());
</code></pre>

<p>Esse código mostra três números aleatórios. Legal? Mas tem um problema.</p>

<p>Ao rodar esse código de novo... os números são os mesmos. Isso é porque o <code>rand()</code>, como quase tudo em um computador, é um pedaço de código que sempre roda a mesma coisa.</p>

<p>Eu não sei dizer a maneira específica como o <code>rand()</code> calcula os números (talvez não seja igual em todos os computadores), mas ele usa como base uma <b>seed</b>. Uma maneira que eu gosto de usar pra explicar isso é com Minecraft. Quando você cria um mundo, você pode especificar uma seed e, se você criar vários mundos com a mesma seed, todos eles vão ser iguais (a início, pelo menos).</p>

<p>Então: dois programas com a mesma <b>seed</b> geram a mesma sequência de números aleatórios.</p>

<p>Para setar a seed de um programa, você pode usar o <code>srand()</code>, também disponível no <code>stdlib.h</code>.</p>

<p>O problema é... o que você coloca na seed? Porque se você colocar uma seed fixa, vai ser a mesma sequência ainda.</p>

<p>Pra isso, podemos usar o <a href="#s-time"><code>time()</code></a>. Como expliquei anteriormente, ele retorna a quantidade de segundos, que é um valor que sempre tá aumentando, e por isso podemos usar isso como seed - toda vez que o programa rodar, a seed vai ser diferente, e então a sequência de números aleatórios vai ser diferente.</p>

<pre><code>srand(time(0));
printf("%d\n", rand());
printf("%d\n", rand());
printf("%d\n", rand());
</code></pre>

<p>Agora funciona.</p>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">aplicação de números aleatórios: dados (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">aplicação de números aleatórios: números dentro de um intervalo (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <details class="subnode"><summary class="big" id="s-funcoes">funções e modularização</summary> <!-- {{{ -->
<p><i>Os exemplos desse capítulo são completos porque a gente vai mexer com coisas "fora" do <code>main()</code>.</i></p>

<p>Como mencionado anteriormente, uma função é um pedaço de código que pode ser rodado várias vezes.</p>

<p>Vamos explicar a importância delas com um exemplo - um programa que mostra um quadrado vazado, 5x5:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int i, j;

    // mostrar o topo do quadrado (1 linha)
    for (i = 0; i &lt; 5; i++)
        printf("*");
    printf("\n");

    // mostrar o meio do quadrado (3 linhas)
    for (i = 0; i &lt; 3; i++) {
        printf("*");
        for (j = 0; j &lt; 3; j++)
            printf(" ");
        printf("*\n");
    }

    // mostrar o topo do quadrado (1 linha)
    for (i = 0; i &lt; 5; i++)
        printf("*");
    printf("\n");
}
</code></pre>

<p>Ao rodar esse programa, a saída é:</p>

<pre><code>*****
*   *
*   *
*   *
*****
</code></pre>

<p>Esse código tem cara de meio confuso, né? É difícil ler de cara o que ele faz. A gente pode adicionar comentários e tal, mas se
começarmos a criar funções, conseguimos chegar a um nível ainda maior de "código compreensível", e conseguimos também diminuir a
repetição de código.</p>

<p>Para criar uma função, podemos fazer:</p>

<pre><code>TIPO_RETORNO NOME_FUNCAO(ARGUMENTOS...) {
    CODIGO_FUNCAO
}
</code></pre>

<p>Isso cria uma função com o nome <code>NOME_FUNCAO</code>, que, quando usada (e você passa <code>ARGUMENTOS</code>), roda o
código <code>CODIGO_FUNCAO</code> e retorna <code>TIPO_RETORNO</code>.</p>

<p>Vamos criar uma função para mostrar uma linha de asteriscos, chamada <code>mostrarLinha</code>:</p>

<pre><code>void mostrarLinha(int tamanho) {
    int i;
    for (i = 0; i &lt; tamanho; i++) {
        printf("*");
    }
    printf("\n");
}
</code></pre>

<p>Para usar ela, basta escrever, por exemplo, <code>mostrarLinha(5)</code>, e ele vai mostrar uma linha com
<code>tamanho=5</code>.</p>

<p>Ao fazer isso, o código fica muito mais simples:</p>

<pre><code>#include &lt;stdio.h&gt;

void mostrarLinha(int tamanho) {
    int i;
    for (i = 0; i &lt; tamanho; i++) {
        printf("*");
    }
    printf("\n");
}

int main() {
    int i, j;

    mostrarLinha(5);

    // mostrar o meio do quadrado (3 linhas)
    for (i = 0; i &lt; 3; i++) {
        printf("*");
        for (j = 0; j &lt; 3; j++)
            printf(" ");
        printf("*\n");
    }

    mostrarLinha(5);
}
</code></pre>

<p>E dá pra melhorar! Se a gente criar uma para mostrar as linhas vazadas também:</p>

<pre><code>#include &lt;stdio.h&gt;

void mostrarLinha(int tamanho) {
    int i;
    for (i = 0; i &lt; tamanho; i++) {
        printf("*");
    }
    printf("\n");
}

void mostrarLinhaVazada(int tamanho) {
    int i;
    printf("*");
    for (i = 0; i &lt; tamanho - 2; i++) {
        printf(" ");
    }
    printf("*");
    printf("\n");
}

int main() {
    int i;

    mostrarLinha(5);
    for (i = 0; i &lt; 3; i++) mostrarLinhaVazada(5);
    mostrarLinha(5);
}
</code></pre>

<p>Eu diria que um dos melhores benefícios de criar funções é que você <b>modulariza</b> o programa. Você consegue separar o
programa em pedaços pequenos que você consegue utilizar quando quiser, quantas vezes quiser, na ordem que quiser. E ainda você
acaba não misturando as variáveis, porque o <code>i</code> em <code>mostrarLinha</code> não é o mesmo <code>i</code> de
<code>mostrarLinhaVazada</code>.</p>

<p>Inclusive, talvez a explicação de argumentos não tenha sido muito boa até agora. As coisas que você passa entre os parênteses,
ao usar a função, vai para as variáveis na função, entre os parênteses também. Então, quando você faz
<code>mostrarLinha(5)</code>, ele roda o código dentro de <code>mostrarLinha</code>, com <code>tamanho</code> sendo igual a
<code>5</code>.</p>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">documentação (A FAZER)</summary> <!-- {{{ -->
                <p>A FAZER: a importância de headers (protótipos e macros)</p>
                <p>A FAZER: man pages, documentação online e mais</p>
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">expressões separadas por vírgula (A FAZER)</summary> <!-- {{{ -->
                isso é desde C89? parece tao estranho...
            </details> <!-- }}} -->
            <details class="subnode"><summary class="todo">pointers (A FAZER)</summary> <!-- {{{ -->
            </details> <!-- }}} -->
            <!-- TALVEZ
                - locale
                - tempo melhorado (struct tm, time format... fusos horários etc)
                - a necessidade do inglês
                - aplicativos gráficos com... SDL? é bem ok mas acho que seria complexo dms pra eu ensinar aqui
                - alocação de memória : stack vs. heap
                - segmentation fault
                - structs
                - typedef
                - early return
                - variáveis globais e por que não usar
                - compilando com gcc/clang/cc, e linking
                - os tipos diferentes de main (argumentos CLI! e return codes)
                - funções recursivas: quando usar, quais os benefícios e malefícios
                - warnings: por que usar?
                - níveis de otimização (-O1, -O2, -O3, -flto) ~ bons pra programas finais mais meio ruins pra testar
            -->
            </details>
        </details>
    </main></body>
</html>
